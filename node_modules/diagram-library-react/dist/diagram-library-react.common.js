'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var mf = require('diagram-library');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

var ControlWrapper =
/*#__PURE__*/
function (_Component) {
  _inherits(ControlWrapper, _Component);

  function ControlWrapper(props) {
    var _this;

    _classCallCheck(this, ControlWrapper);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ControlWrapper).call(this, props));
    _this.element = React__default.createRef();
    return _this;
  }
  /**
  * Sets a control property from props.
  * @private
  */


  _createClass(ControlWrapper, [{
    key: "setProp",
    value: function setProp(propName) {
      if (this.props[propName] !== undefined) {
        var setter = "set" + propName[0].toUpperCase() + propName.substr(1);
        this.control[setter](this.props[propName]);
      }
    }
    /**
    * Sets all control properties from props.
    * @private
    */

  }, {
    key: "setProps",
    value: function setProps(prevProps) {
      var _this2 = this;

      if (prevProps) {
        this.controlProps.forEach(function (p) {
          if (_this2.props[p] !== prevProps[p]) _this2.setProp(p);
        });
      } else {
        this.controlProps.forEach(function (p) {
          _this2.setProp(p);
        });
      }
    }
    /**
    * Sets a control event from props.
    * @private
    */

  }, {
    key: "setEvent",
    value: function setEvent(eventName) {
      var handlerName = "on" + eventName[0].toUpperCase() + eventName.substr(1);

      if (this.props[handlerName] !== undefined) {
        var delegate = mf.AbstractionLayer.createDelegate(this, this.props[handlerName]);
        this.control.addEventListener(eventName, delegate);
      }
    }
    /**
    * Gets the list of control properties, that can be set from JSX.
    * @private
    */

  }, {
    key: "attachControl",

    /**
    * Binds the control to its DOM element and sets its properties from JSX props.
    * @private
    */
    value: function attachControl() {
      mf.AbstractionLayer.attachControl(this.control, this.element.current);
      this.setProps();
    }
    /**
    * Late-binds a diagram to the control. 
    * @private
    */

  }, {
    key: "bindDiagram",
    value: function bindDiagram(diagram) {
      if (diagram.get_element()) this.attachDiagram(diagram);else diagram.addEventListener(mf.Diagramming.Events.controlLoaded, this.attachDiagram.bind(this));
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.attachControl();

      if (this.props.diagram) {
        this.bindDiagram(this.props.diagram);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.props.diagram) this.bindDiagram(this.props.diagram);
      this.setProps(prevProps);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      // dispose
      if (this.control) this.control.dispose();
    }
  }, {
    key: "render",
    value: function render() {
      return React__default.createElement("div", null);
    }
  }, {
    key: "controlProps",
    get: function get() {
      return [];
    }
  }]);

  return ControlWrapper;
}(React.Component);

var DiagramView =
/*#__PURE__*/
function (_ControlWrapper) {
  _inherits(DiagramView, _ControlWrapper);

  function DiagramView() {
    _classCallCheck(this, DiagramView);

    return _possibleConstructorReturn(this, _getPrototypeOf(DiagramView).apply(this, arguments));
  }

  _createClass(DiagramView, [{
    key: "attachControl",
    value: function attachControl(diagram) {
      // initialize with the DOM element
      this.control = mf.AbstractionLayer.attachControl(diagram, this.element.current); // set props

      this.setProps();
      this.control.setVirtualScroll(true);
      this.control.invalidate();
      var events = mf.Diagramming.Events;

      for (var e in events) {
        this.setEvent(e);
      } // listen for changes


      var changedDelegate = mf.AbstractionLayer.createDelegate(this, this.raiseDiagramChanged);
      diagram.addEventListener(mf.Diagramming.Events.nodeCreated, changedDelegate);
      diagram.addEventListener(mf.Diagramming.Events.nodeModified, changedDelegate);
      diagram.addEventListener(mf.Diagramming.Events.nodeDeleted, changedDelegate);
      diagram.addEventListener(mf.Diagramming.Events.linkCreated, changedDelegate);
      diagram.addEventListener(mf.Diagramming.Events.linkModified, changedDelegate);
      diagram.addEventListener(mf.Diagramming.Events.linkDeleted, changedDelegate);
      diagram.addEventListener(mf.Diagramming.Events.nodeTextEdited, changedDelegate);
      diagram.addEventListener(mf.Diagramming.Events.linkTextEdited, changedDelegate);
      diagram.addEventListener(mf.Diagramming.Events.cellTextEdited, changedDelegate);
      diagram.addEventListener(mf.Diagramming.Events.laneGridCellTextEdited, changedDelegate);
      diagram.addEventListener(mf.Diagramming.Events.containerChildAdded, changedDelegate);
      diagram.addEventListener(mf.Diagramming.Events.containerChildRemoved, changedDelegate);
    }
  }, {
    key: "raiseDiagramChanged",
    value: function raiseDiagramChanged() {
      // raise the diagramChanged event
      if (this.props.onDiagramChanged) this.props.onDiagramChanged(this, mf.EventArgs.Empty);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.diagram) {
        this.attachControl(this.props.diagram);
      }
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      // if a new diagram was created dispose the old diagram and attach the new one
      if (nextProps.diagram == null) {
        this.control.dispose();
      }

      if (nextProps.diagram) {
        if (!nextProps.diagram.get_element()) {
          if (this.control) {
            this.control.dispose();
          }

          this.attachControl(nextProps.diagram);
        }
      }

      return true;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      this.setProps(prevProps);
    }
  }, {
    key: "render",
    value: function render() {
      var defaultStyle = {
        overflow: "auto",
        height: "100%",
        width: "100%",
        textAlign: "left"
      };
      var style = Object.assign({}, defaultStyle, this.props.style);
      return React__default.createElement("div", {
        className: "mf-react-diagram",
        style: style
      }, React__default.createElement("canvas", {
        width: "200",
        height: "200",
        ref: this.element,
        id: this.props.id
      }));
    }
  }, {
    key: "controlProps",
    get: function get() {
      return ["allowInplaceEdit", "autoResize", "backBrush", "behavior", "defaultShape", "enabled", "linkHeadShapeSize", "linkShape", "roundedLinks", "routeLinks", "showAnchors", "showGrid"];
    }
  }]);

  return DiagramView;
}(ControlWrapper);

var Overview =
/*#__PURE__*/
function (_ControlWrapper) {
  _inherits(Overview, _ControlWrapper);

  function Overview(props) {
    var _this;

    _classCallCheck(this, Overview);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Overview).call(this, props));
    _this.control = new mf.Diagramming.Overview();
    return _this;
  }

  _createClass(Overview, [{
    key: "attachDiagram",
    value: function attachDiagram(diagram) {
      this.control.setDiagram(diagram);
      this.control.repaint();
    }
  }, {
    key: "render",
    value: function render() {
      var defaultStyle = {
        height: "200px",
        width: "200px"
      };
      var style = Object.assign({}, defaultStyle, this.props.style);
      return React__default.createElement("div", {
        className: "mf-react-overview",
        style: style
      }, React__default.createElement("canvas", {
        width: "200",
        height: "200",
        ref: this.element,
        id: this.props.id
      }));
    }
  }, {
    key: "controlProps",
    get: function get() {
      return ["enabled", "backColor", "dimColor", "scaleFactor", "scaleMode", "allowZoom", "autoScrollAmount"];
    }
  }]);

  return Overview;
}(ControlWrapper);

var NodeListView =
/*#__PURE__*/
function (_ControlWrapper) {
  _inherits(NodeListView, _ControlWrapper);

  function NodeListView() {
    _classCallCheck(this, NodeListView);

    return _possibleConstructorReturn(this, _getPrototypeOf(NodeListView).apply(this, arguments));
  }

  _createClass(NodeListView, [{
    key: "addNode",

    /**
    * Adds a node to the NodeListView.
    * @param {MindFusion.Diagramming.DiagramNode} node The node to add.
    * @param {String} [caption] The caption to display for the node.
    */
    value: function addNode(node, caption) {
      this.control.addNode(node, caption);
    }
  }, {
    key: "attachControl",
    value: function attachControl() {
      this.control = mf.Diagramming.NodeListView.create(this.element.current);
      this.setProps();
      this.setEvent("nodeSelected");
      this.resetNodes();
    }
  }, {
    key: "resetNodes",

    /**
    * Resets the control nodes from values in props.
    * @private
    */
    value: function resetNodes() {
      this.control.clearAll();

      if (this.props.nodes !== undefined) {
        for (var i = 0; i < this.props.nodes.length; ++i) {
          var caption = this.props.captions ? this.props.captions.length > i ? this.props.captions[i] : "" : "";
          this.control.addNode(this.props.nodes[i], caption);
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.attachControl();
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      return true;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      this.setProps(prevProps);

      if (prevProps.nodes !== this.props.nodes || prevProps.captions !== this.props.captions) {
        this.resetNodes();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var defaultStyle = {
        height: "200px",
        width: "200px",
        overflowY: "auto",
        overflowX: "hidden"
      };
      var style = Object.assign({}, defaultStyle, this.props.style);
      return React__default.createElement("div", {
        className: "mf-react-nodelistview",
        style: style
      }, React__default.createElement("canvas", {
        width: "200",
        height: "200",
        ref: this.element,
        id: this.props.id
      }));
    }
  }, {
    key: "controlProps",
    get: function get() {
      return ["enabled", "iconSize", "defaultNodeSize", "padding", "orientation", "tooltipDelay", "shapeLibraryLocation"];
    }
  }]);

  return NodeListView;
}(ControlWrapper);

var ZoomControl =
/*#__PURE__*/
function (_ControlWrapper) {
  _inherits(ZoomControl, _ControlWrapper);

  function ZoomControl(props) {
    var _this;

    _classCallCheck(this, ZoomControl);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ZoomControl).call(this, props));
    _this.control = new mf.Controls.ZoomControl();
    return _this;
  }

  _createClass(ZoomControl, [{
    key: "attachDiagram",
    value: function attachDiagram(diagram) {
      this.control.setZoomFactor(100);
      this.control.setTarget(diagram);
    }
  }, {
    key: "render",
    value: function render() {
      var defaultStyle = {
        height: 300,
        width: 50
      };
      var style = Object.assign({}, defaultStyle, this.props.style);
      return React__default.createElement("div", {
        className: "mf-react-zoomcontrol",
        style: style
      }, React__default.createElement("canvas", {
        width: "50",
        height: "300",
        ref: this.element,
        id: this.props.id
      }));
    }
  }, {
    key: "controlProps",
    get: function get() {
      return ["enabled", "cornerRadius", "padding", "snapToZoomStep", "tickPosition", "showLabel", "textColor", "shadowColor", "innerColor", "borderColor", "activeColor", "fill", "backColor", "scrollStep", "zoomStep", "maxZoomFactor", "minZoomFactor", "zoomFactor"];
    }
  }]);

  return ZoomControl;
}(ControlWrapper);

var Ruler =
/*#__PURE__*/
function (_ControlWrapper) {
  _inherits(Ruler, _ControlWrapper);

  function Ruler(props) {
    var _this;

    _classCallCheck(this, Ruler);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Ruler).call(this, props));
    _this.control = new mf.Diagramming.Ruler();
    return _this;
  }

  _createClass(Ruler, [{
    key: "attachDiagram",
    value: function attachDiagram(diagram) {
      this.control.setDiagram(diagram);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.attachControl();

      if (this.diagramView) {
        var diagram = this.diagramView.props.diagram;

        if (diagram) {
          this.bindDiagram(diagram);
        }
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      _get(_getPrototypeOf(Ruler.prototype), "componentDidUpdate", this).call(this, prevProps, prevState);

      if (prevProps.children.props.diagram !== this.diagramView.props.diagram) {
        this.control.setDiagram(this.diagramView.props.diagram);
      } else this.control.refreshScales();
    }
  }, {
    key: "render",
    value: function render() {
      var defaultStyle = {
        display: "inline-block",
        textAlign: "left"
      };
      var style = Object.assign({}, defaultStyle, this.props.style);
      this.diagramView = React__default.Children.only(this.props.children);
      return React__default.createElement("div", {
        className: "mf-react-ruler",
        ref: this.element,
        id: this.props.id,
        style: style
      }, this.diagramView);
    }
  }, {
    key: "controlProps",
    get: function get() {
      return ["unit", "enableGuides", "projectRotatedBounds", "negatedY", "negatedX", "verticalScaleVisible", "horizontalScaleVisible", "pointerColor", "textColor", "guideColor", "projectionColor", "backColor", "foreColor"];
    }
  }]);

  return Ruler;
}(ControlWrapper);

exports.DiagramView = DiagramView;
exports.NodeListView = NodeListView;
exports.Overview = Overview;
exports.Ruler = Ruler;
exports.ZoomControl = ZoomControl;
